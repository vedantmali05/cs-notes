<!DOCTYPE html>

<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Unit 1 Software Development Process - SEN</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Stylesheet -->
    <link rel="stylesheet" href="style-global.css">
    <link rel="stylesheet" href="style-header.css">
    <link rel="stylesheet" href="style-main.css">
    <link rel="stylesheet" href="style-footer.css">
    <link rel="stylesheet" href="style-prose.css">

    <!-- FONTS -->
    <!-- Font - POPPINS, LORA, ROBOTO MONO, ROBOTO -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Roboto+Mono:ital,wght@0,400;0,500;0,600;1,400;1,500;1,600&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"
        rel="stylesheet">


    <!-- ICONS -->
    <!-- Icons - Bootstrap -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.8.1/font/bootstrap-icons.css">

</head>

<body>

    <!-- MAIN SECTION -->
    <main class="notes-main" id="notes-main">
        <!-- Course Intro -->
        <section class="course-intro-wrapper">
            <!-- COURSE CONTENTS -->
            <div class="course-intro-contents">
                <div class="eyebrow">1.0</div>
                <h1 class="course-heading">Software Development Process</h1>
                <p class="course-intro-para">
                    The basics of Software Enggineering and the process of software development in brief.
                </p>
            </div>
            <figure class="course-intro-hero">
                <img src="images/illu-hero.png" alt="">
            </figure>
        </section>
        <!-- Table of Contents -->
        <section class="index-wrapper">
            <!-- Index List -->
            <ul class="index-list-box show-index">
                <!-- AUTOMATED IN JAVASCRIPT -->
                <!-- CONTENTS WILL BE AUTOMATICALLY ADDED -->
            </ul>

            <!-- Index title -->
            <div class="index-title show-index">
                <h2>On this page</h2>
                <span class="expand-index">
                    <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#000000"><path d="M24 24H0V0h24v24z" fill="none" opacity=".87"/><path d="M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6-1.41-1.41z"/></svg>
                </span>
            </div>
        </section>

        <!-- TOPIC NOTES STARTS -->
        <!-- TOPIC PROSE -->
        <section class="topic-prose-wrapper">
            <article class="topic-prose">
                <!-- TOPIC - SOFTWARE -->
                <h1 id="topic_software" class="prose-heading-1">1.1 Software</h1>
                <aside class="key definition">
                    <div class="key-header">
                        <span class="key-icon">📙</span>
                        <h2 class="prose-heading-2">Definition - Software</h2>
                    </div>
                    <div class="key-content">
                        <p class="prose-para">
                            A set of instructions, data or programs used to operate computer and execute specific task is known as a
                            <span class="highlight">Software</span>
                        </p>
                    </div>
                </aside>
                <p class="prose-para">
                    A software is a variable part of a computer and hardware is invariable.
                </p>
                <p class="prose-para">
                    <span class="highlight">History of Softwares</span>:- (in short 🙂) Before 1980s, a software was used to be written on the hardware it ran on. During and after 1980s, the software setup was used to be stored on floppy disks and it
                    was installed in any computer (with all rights.) Later on, CDs and DVDs were introduced for the same purpose. In the present day, the softwares can be directly downloaded using Internet.
                </p>
                <!-- Subtopic -->
                <article class="subtopic-1">
                    <h2 id="topic_senAsLayeredApproach" class="prose-heading-2">
                        Software Enggineering as Layered Approach
                    </h2>
                    <p class="prose-para">
                        Softwares are becoming more and more complex and functional due to technological advances. Before, conference calling was not even possible and now hundreds of people connect together to play a game. Hence, now a need of advance from basic programming
                        principle is raised and Software Enggineering came to rescue.
                    </p>
                    <p class="prose-para">
                        Software Enggineering Teams are required to study user needs, go designing, implement and test end product.
                    </p>
                    <p class="prose-para">According to <a href="https://www.ieee.org/" target="_blank">IEE.org</a>, software enggineering is "The application of a systematic displined, quantifiable approach to the development, operation and maintenance of software i.e. the
                        application of enggineering to software."</p>

                    <aside class="key tip simplification">
                        <div class="key-header">
                            <span class="key-icon">🙂</span>
                            <h2 class="prose-heading-2">Simply</h2>
                        </div>
                        <div class="key-content">
                            <p class="prose-para">
                                The above statement means - the layered approach of software is - Software Enggineering is a systematic approach used by professionals to develop complex software end products within a given time and budget.
                            </p>
                        </div>
                    </aside>
                    <!-- Subtopic 2 -->
                    <article class="subtopic-2">
                        <h3 class="prose-heading-3">
                            4 layers of Software Enggineering
                        </h3>
                        <ol class="prose-list">
                            <li class="prose-para">
                                <span class="highlight">Tools</span>:- Contains automated or semi-automated tools offering support to framework and method each Software Enggineering project will follow. Ex: <a href="https://developers.google.com/web/tools"
                                    target="_blank">Google Developer Tools</a> are the tool used for web development.
                            </li>
                            <li class="prose-para">
                                <span class="highlight">Methods</span>:- This contains the technical knowledge and "How-tos..." in order to develop a software.
                            </li>
                            <li class="prose-para">
                                <span class="highlight">Process</span>:- Is a framework that must be established for the effective delivery of software.
                            </li>
                            <li class="prose-para">
                                <span class="highlight">A Quality Focus</span>:- It is important to test end product according to simplifications like efficiency, usuability, maintenance and reusuability.
                            </li>
                        </ol>
                    </article>
                </article>
                <!-- Subtopic 1 -->
                <article class="subtopic-1">
                    <h2 id="topic_charOfSen" class="prose-heading-2">
                        Characteristics of Software Enggineering
                    </h2>
                    <p class="prose-para">
                        Following are the Characteristics of Software Enggineering that a good product must have:-
                    </p>
                    <ol class="prose-list">
                        <li class="prose-para">
                            <span class="highlight">Functionality</span>:- It is the degree of performance versus its meant purpose.
                        </li>
                        <li class="prose-para">
                            <span class="highlight">Reliability</span>:- A set of attributes having the capability of software to maintain its performance level under given condition.
                        </li>
                        <li class="prose-para">
                            <span class="highlight">Efficiency</span>:- Ability of a software to use system resources effectively and efficiently.
                        </li>
                        <li class="prose-para">
                            <span class="highlight">Usuability</span>:- The extent to which a software can be used with ease. Also, it defines, the amount of time and efforts required to learn how to use the software.
                        </li>
                        <li class="prose-para">
                            <span class="highlight">Maintainability</span>:- The ease with which modifications can be made in a software for updates, bug fixes or improvements.
                        </li>
                        <li class="prose-para">
                            <span class="highlight">Portability</span>:- Able to transfer software from one environment to another without or with minimum changes. Ex: Some softwares won't run if they are shared to another computer, they must be installed
                            according to each environment.
                        </li>
                    </ol>
                </article>
                <article class="subtopic-1">
                    <h2 id="topic_typesOfSoftware" class="prose-heading-2">
                        Types of Software
                    </h2>
                    <ul class="prose-list">
                        <!-- TODO: JUST COMPLETE ALL THE SUBCATEGORIES in Application Software -->
                        <!-- <li class="prose-para">
                            <span class="highlight">Enggineering or Scientific Software</span>:-
                        </li>
                        <li class="prose-para">
                            <span class="highlight">Embedded Software</span>:-
                        </li>
                        <li class="prose-para">
                            <span class="highlight">Product-line Software</span>:-
                        </li>
                        <li class="prose-para">
                            <span class="highlight">Enggineering or Scientific Software</span>:-
                        </li> -->
                        <li class="prose-para">
                            <span class="highlight">Application Software</span>:- A software which fulfills a specific need or perform any specific task. Ex:- File Explorer, Calculator, etc. <span class="highlight">Programming Software</span> is a sub-category
                            of application software which are used to provide programming tools to developers. Ex:- Microsoft VS Code IDE.
                        </li>
                        <li class="prose-para">
                            <span class="highlight">System Software</span>:- A software on which computer's hardware works is a System Software. Every Operating System like Windows, Linux or macOS is a System Software. It is a platform for Application
                            Software.
                        </li>
                        <li class="prose-para">
                            <span class="highlight">Middleware</span>:- This software lies between System Software and Application Software which then controls the computer devices and its peripherals.
                        </li>

                    </ul>
                </article>
                <h1 id="topic_softwareDevelopmentFramework" class="prose-heading-1">1.2 Software Development Framework</h1>
                <aside class="key definition">
                    <div class="key-header">
                        <span class="key-icon">📙</span>
                        <h2 class="prose-heading-2">Definition - Framework</h2>
                    </div>
                    <div class="key-content">
                        <p class="prose-para">The set of <span class="highlight">activities</span> which are applicable to all software or app projects and domains are <span class="highlight">Frameworks</span>.</p>
                    </div>
                </aside>
                <p class="prose-para">Basically, they are the collection of related actions that produce a major product. And these actions are made by accomplishing work tasks. More simplifying, they are the templates for for every process of Software Development.</p>
                <article class="subtopic-1">
                    <h2 class="prose-heading-2">
                        Common <span class="highlight">Phases</span> in all Software Development Process Models:-
                    </h2>
                    <ul class="prose-list">
                        <li class="prose-para">
                            <span class="highlight">
                                Communication
                            </span>:- To gather all the requirements a software needs like tools, programmers, designers, etc. heavy communication is carried out with customers and other stakeholders.
                        </li>
                        <li class="prose-para">
                            <span class="highlight">Planning
                            </span>:- This phase describes the technical tasks to be conducted, risks may raise on the way, resources will be required, end product and work schedule.
                        </li>
                        <li class="prose-para">
                            <span class="highlight">Modelling</span>:- In this phase the models that let the developers and customers better understand the software requirements and the designs achieving those requirements are created.
                        </li>
                        <li class="prose-para">
                            <span class="highlight">Construction
                            </span>:- This phase is of code generation, testing and debugging every error in the software.
                        </li>
                        <li class="prose-para">
                            <span class="highlight">Deployment
                            </span>:- In this phase, the product is presented before customer before launching the final product for feedback and better supply of product. (It is like Beta Mode)
                        </li>

                    </ul>
                    <aside class="key tip simplification">
                        <div class="key-header">
                            <span class="key-icon">🙂</span>
                            <h2 class="prose-heading-2">Remember</h2>
                        </div>
                        <div class="key-content">
                            <p class="prose-para"> Remember these phases as the acronym <span class="highlight">CPMCD</span> - Communication, Planning, Modelling, Construction and Deployment.</p>
                            <p class="prose-para">All the phases in a software development process together create a Software Development <span class="highlight">Life Cycle</span> or <span class="highlight">SDLC</span>.</p>
                        </div>
                    </aside>
                </article>
                <article class="subtopic-1">
                    <h2 class="prose-heading-2">Umbrella Activities:-
                    </h2>
                    <p class="prose-para">
                        Umbrella Activities are the steps expressed or available in different ways in different software processes followed by a software development teams to maintain progress, quality, changes and risks.
                    </p>
                    <ul class="prose-list">
                        <li class="prose-para">
                            <span class="highlight">Software project tracking and control
                            </span>:- Let the team assess (judge) with project plan and take needed actions to maintain it.
                        </li>
                        <li class="prose-para">
                            <span class="highlight">Risk management
                            </span>:- Assess risks that may affect the end product.
                        </li>
                        <li class="prose-para">
                            <span class="highlight">Software quality assuarance
                            </span>:- Define and do the activities required to ensure quality of the product.
                        </li>
                        <li class="prose-para">
                            <span class="highlight">Formal technical reviews
                            </span>:- Resolve or Debug the problems or errors before they spread or affect the next action.
                        </li>
                        <li class="prose-para">
                            <span class="highlight">Measurement
                            </span>:- Defines and collects process, project and product measures to assist developer team.
                        </li>
                        <li class="prose-para">
                            <span class="highlight">Software configuration management
                            </span>:- Manage the effect of change throughout the process.
                        </li>
                        <li class="prose-para">
                            <span class="highlight">Re-usuability management
                            </span>:- Defines criteria for work product reuse.
                        </li>
                        <li class="prose-para">
                            <span class="highlight">Work product preparation and production
                            </span>:- Encompasses (encircle) the activities required to create work products like models, documentation, etc.
                        </li>
                    </ul>
                </article>
                <h1 id="topic_swProcessModel" class="prose-heading-1">1.3 Software Process Models</h1>
                <p class="prose-para">
                    A Software Process Model is an abstract representation of a software development process. It describes the "How To Do's" for a software development by specifying development stages and <span class="highlight">order of a process</span>.
                </p>
                <ul class="prose-list">
                    <p class="prose-para">A software process models defines to establish the end product:-</p>
                    <li class="prose-para">The tasks to be performed</li>
                    <li class="prose-para">Input and Output for each task</li>
                    <li class="prose-para">Pre and Post conditions for each task</li>
                    <li class="prose-para">Flow and sequence of each task</li>
                </ul>
                <aside class="key callout">
                    <div class="key-header">
                        <span class="key-icon">💡</span>
                        <h2 class="prose-heading-2">Goal of a S/W Process Model</h2>
                    </div>
                    <div class="key-content">
                        <p class="prose-para">The goal of a software process model is to provide guidance for controlling and coordinating the task to achieve the end product and objectives as effectively as possible.</p>
                    </div>
                </aside>
                <ol class="prose-list">
                    <p class="prose-para">There are 2 types of Software Process Models:-</p>
                    <li class="prose-para">Prescriptive Process Models</li>
                    <li class="prose-para">Specialized Process Models</li>
                </ol>

                <article class="subtopic-1">
                    <h2 id="topic_perscriptiveProcessModels" class="prose-heading-2">
                        Prescriptive Process Models
                    </h2>
                    <p class="prose-para">Prescriptive Process Models are the conventional (or typical) process models used when the chosen software enggineering approach is described in detail. These models are called "Prescriptive" because they <span class="highlight">prescribe</span>                        the set of activities, actions, tasks and modifications for every project. There are 3 Prescriptive Models:-
                    </p>

                    <article class="subtopic-2">
                        <h3 class="prose-heading-3">1. Waterfall Models</h3>
                        <p class="prose-para">
                            Here, each phase must be fully completed before starting next phase. This Model is also known as <span class="highlight">Linear Sequencial Models</span> aka <span class="highlight">Classic Life Cycle Models</span>. This model
                            consists of CPMCD - Communication, Planning, Modelling, Construction and Deployment and testing and debugging is done after completing all phases.
                        </p>
                        <ul class="prose-list">
                            <p class="prose-para">
                                <span class="highlight"> Advantages of Waterfall Models:-</span>
                            </p>
                            <li class="prose-para">Simple to understand and has no uncertain requirements.</li>
                            <li class="prose-para">The phases of the life cycle don't overlap.</li>
                            <li class="prose-para">Works well on the small projects.</li>
                        </ul>
                        <ul class="prose-list">
                            <p class="prose-para">
                                <span class="highlight"> Disadvantages of Waterfall Models:-</span>
                            </p>
                            <li class="prose-para">As testing is carried out the complete life cycle, going back and fixing error is difficult.</li>
                            <li class="prose-para">Risky and Uncertain where requirements are at the risk of changing.</li>
                            <li class="prose-para">Not good for complex and Object Oriented Projects.</li>
                        </ul>
                    </article>
                    <article class="subtopic-2">
                        <h3 class="prose-heading-3">2. Incremental Process Models</h3>
                        <p class="prose-para">
                            Here, requirements are divided into various builds making a "multi-waterfall" cycle. These cycles are divided upto smaller and more managable modules. Each model passes through requirement, design, testing, etc. Then, a working version of software is produced
                            during first module and upcoming modules add more functions and features to previous release. Hence, a working product is available at the early stage.
                        </p>
                        <ul class="prose-list">
                            <p class="prose-para">
                                <span class="highlight"> Advantages of Incremental Process Models:-</span>
                            </p>
                            <li class="prose-para">A working product is available at the early stage.</li>
                            <li class="prose-para">More flexible - less costly to modify scope and requirement. Hence, it increases risk management.</li>
                            <li class="prose-para">Easy to test and debug as iterations are small.</li>
                            <li class="prose-para">Here, customer can respond to each feed.</li>
                        </ul>
                        <ul class="prose-list">
                            <p class="prose-para">
                                <span class="highlight"> Disadvantages of Incremental Process Models:-</span>
                            </p>
                            <li class="prose-para">requires good planning and design.</li>
                            <li class="prose-para">Total cost is higher than waterfall.</li>
                        </ul>
                    </article>
                    <article class="subtopic-2">
                        <h3 class="prose-heading-3">2. Rapid Application Development (RAD) Models</h3>
                        <p class="prose-para">
                            The RAD model is similar to Incremental process model, where components and functions are developed parallely like mini projects. The developments are time boxed, delivered and assembled into working prototype.
                        </p>
                        <ul class="prose-list">
                            <p class="prose-para">
                                <span class="highlight"> Advantages of RAD Models:-</span>
                            </p>
                            <li class="prose-para">Reduces development time</li>
                            <li class="prose-para">Increases reusuability components</li>
                            <li class="prose-para">Fastens and encourages customer feedback</li>
                        </ul>
                        <ul class="prose-list">
                            <p class="prose-para">
                                <span class="highlight"> Disadvantages of RAD Models:-</span>
                            </p>
                            <li class="prose-para">Depends on stronger team and individual performances.</li>
                            <li class="prose-para">Only the system which can be broke into modules can be made using RAD models.</li>
                            <li class="prose-para">Requires highly skilled developers or designers.</li>
                        </ul>
                    </article>
                </article>
                <article class="subtopic-1">
                    <h2 id="topic_specializedProcessModels" class="prose-heading-2">
                        Specialized Process Models
                    </h2>
                    <aside class="key definition">
                        <div class="key-header">
                            <span class="key-icon">📙</span>
                            <h2 class="prose-heading-2">Definition - Specialized Process Models</h2>
                        </div>
                        <div class="key-content">
                            <p class="prose-para">
                                The models made by combining one or more conventional models are <span class="highlight">Specialized Process Models</span>.
                            </p>
                        </div>
                    </aside>
                    <p class="prose-para">Thus these models has many characteristics of multiple conventional models. It is applicable where a narrowly defined software enggineering process approach is chosen.
                    </p>
                </article>

                <h1 id="topic_agileSwDev" class="prose-heading-1">1.4 Agile Software Development</h1>
                <p class="prose-para">Also known as Agile meaning flexible (Able to create changes). </p>
                <aside class="key definition">
                    <div class="key-header">
                        <span class="key-icon">📙</span>
                        <h2 class="prose-heading-2">Definition - Agile Software Development</h2>
                    </div>
                    <div class="key-content">
                        <p class="prose-para">A quick and appropriate response to the change incorporating (include) the changes in software process is done in Agile. </p>
                    </div>
                </aside>
                <p class="prose-para">In Agile, the customers and their interactions are focussed more than the tools. The traditional software development models like Waterfall Model take a long time to modify so they cannot be Agile. Thus, usually Agile are based on incremental
                    methods where easy and fast modifications are one of the main advantages.
                </p>
                <p class="prose-para">
                    In Agile, each project is broken up into several iterations in given deadline. Each iteration includes continuous planning, testing, integration. After each iteration, feedback is taken and implemented on upcoming iterations. A working product must be
                    delivered at the end of every iteration.It focusses on keeping code simple, testing often and delivering a function unit as soon as possible.
                </p>

                <article class="subtopic-1">
                    <h2 class="prose-heading-2">Advantages of Agile Software Developments:- </h2>
                    <ul class="prose-list">
                        <li class="prose-para">Predictable cost and time frame. Early and predictable delivery.</li>
                        <li class="prose-para">Improved quality and transperancy.</li>
                        <li class="prose-para">Business engagement or customer satisfaction.</li>
                        <li class="prose-para">Managable, adaptive and reliable end product.</li>
                    </ul>
                    <h2 class="prose-heading-2">🙂 Disadvantages of Agile Software Developments:- </h2>
                    <ul class="prose-list">
                        <li class="prose-para">In Agile, documentation happens throughout a project, and often “just in time” for building the output, not at the beginning. So it is limited in Agile.</li>
                        <li class="prose-para">Fragmented output</li>
                    </ul>
                </article>

                <article class="subtopic-1">
                    <h2 class="prose-heading-2">Types of Agile Methodologies</h2>
                    <article class="subtopic-2">
                        <h3 id="topic_agileAsd" class="prose-heading-3">1. Adaptive Software Development (ASD)</h3>
                        <p class="prose-para">
                            Adaptive Software Development is a framework typically used in complex softwares. Its life cycle includes.
                            <ul class="prose-list">
                                <li class="prose-para"><span class="highlight">Speculation</span>:- The project is initiated and planned. The planning includes project requirements, user needs and customer mission statement.</li>
                                <li class="prose-para"><span class="highlight">Collaboration</span>:- Communication and teamwork but emphasizes for creativity.</li>
                                <li class="prose-para"><span class="highlight">Learning</span>:- Learning helps workers to increase their level of understanding over the project in 3 ways - focussed groups, technical reviews and project postmorten.</li>
                            </ul>
                        </p>
                    </article>
                    <article class="subtopic-2">
                        <h3 id="topic_agileXp" class="prose-heading-3">2. Extreme Programming (XP) </h3>
                        <p class="prose-para">
                            XP is a disciplined approach focussing on speed and continuous delivery like increased customer involvement, fast feedback loop, continuous planning and testing, etc. High quality product delivery is expected and teams are supported by providing lightweight
                            frameworks to do so.
                        </p>
                    </article>
                    <article class="subtopic-2">
                        <h3 id="topic_agileScrum" class="prose-heading-3">
                            3. Scrum
                        </h3>
                        <p class="prose-para">
                            In Scrum, the owner creates a <span class="highlight">product backlog</span> that allows them to work with their team to identify and prioritize system functions. 💡 A product backlog is the "To-Do List" or notes having every
                            necessary component or task to deliver a successfull software. The backlog includes details about bug fixes, features list and non-functional requirements. This list is final i.e nothing can be added to it once it is defined.
                            But in some cases, the team can modify the list. Once the backlog is finalized, the team works and delivers one increment in a sprint of usually 30 days. Then after every sprint, the product backlog is re-evaluated, analyzed
                            and prioterized for the next sprint. It is simple and productive to incorporate various practices of other Agile methods in Scrum.
                        </p>
                    </article>
                    <article class="subtopic-2">
                        <h3 id="topic_agileDsdm" class="prose-heading-3">4. Dynamic System Development Method (DSDM)</h3>
                        <p class="prose-para">This is said to be a common industryy framework.</p>
                        <ol class="prose-list">
                            <p class="prose-para">Defines 8 principles which are super necessary:- (Unaccepting any of the principles will introduce risks)</p>
                            <li class="prose-para">Collaboration</li>
                            <li class="prose-para">On-time delivery</li>
                            <li class="prose-para">Demostrated control</li>
                            <li class="prose-para">Continuous and clear communication</li>
                            <li class="prose-para">A constant focus on business need.</li>
                            <li class="prose-para">Iterative Development</li>
                            <li class="prose-para">Creation in increments from firm foundations</li>
                            <li class="prose-para">Refusal to compromise quality.</li>
                        </ol>
                        <p class="prose-para">In DSDM, system requirements are prioritized using <span class="highlight">MoSCoW</span> - <span class="highlight">M</span>ust have, <span class="highlight">S</span>hould have, <span class="highlight">C</span>ould have, but not
                            critical and <span class="highlight">W</span>on't have now, but could have later. Here, not every requirement is critical thus they can be removed without impacting the higher priority requirements.
                    </article>
                    <article class="subtopic-2">
                        <h3 id="topic_agileCrystal" class="prose-heading-3">5. Crystal</h3>
                        <p class="prose-para">
                            Crystal is the most lightweight and adaptive methodology which focusses on people and their interactions happening while working on an Agile projec, business critiality and priority of the system under development. It works on the realization that every
                            project possesses unique characteristics (like project priorities, team sizes, system cricalities) that require a slightly tailored 🔧 set of policies, practices, and processes. Thus, it has different types like Crystal Orange,
                            Crystal Clear and Crystal Yellow. It also emphasizes frequent delivery of a working product with high customer involvement, adaptibility, etc. The priciples of Crystal methodology are - communication, teamwork and simplicity.
                        </p>
                    </article>
                </article>

                <h1 id="topic_selectionCriteria_SwProcessModel" class="prose-heading-1">1.5 Selection Criteria for Software Process Models</h1>
                <ol class="prose-list">
                    <p class="prose-para">Selection process parameters play important roles in choosing the best Software Development Life Cycle. They are as follows:-</p>
                    <li class="prose-para">
                        <span class="highlight">Requirement Characteristics</span>:- Requirements indicate the complexity of system
                        <ul class="prose-list">
                            <li class="prose-para">Reliability of requirements, how often the requirements can change? Types and number of requirements, can they be defined early? </li>
                        </ul>
                    </li>
                    <li class="prose-para">
                        <span class="highlight">Developer team</span>:-
                        <ul class="prose-list">
                            <li class="prose-para">Size, experience of the developers on the similar project, level of understanding of user requirements by developers, developer's environment, domain knowledge of development, experience on the tech to be used, availability
                                of training.</li>
                        </ul>
                    </li>
                    <li class="prose-para">
                        <span class="highlight">User involvement in the project</span>:-
                        <ul class="prose-list">
                            <li class="prose-para">Expertise of user in project, involvement of user in all phases, experience of user in similar project in past.</li>
                        </ul>
                    </li>
                    <li class="prose-para">
                        <span class="highlight">Project type and associated risks</span>:-
                        <ul class="prose-list">
                            <li class="prose-para">Stability of funds, tightness of project schedule, availability of resources, types of project, size of project, expected time frame, complexity of project, level and type of associated risk.</li>
                        </ul>
                    </li>
                </ol>
            </article>
        </section>

        <!-- PROSE ENDS -->

        <!-- Next Prose Links -->
        <section class="adj-prose-wrapper">
            <a href="#" class="next-prose-box adj-prose-link">
                <div class="direction">
                    <span><i class="bi bi-arrow-right"></i></span><span>Next</span><span class="prose-num">2.0</span>
                </div>
                <h1 class="adj-prose-topic">
                    Unit 2 - Software Requirement Framework
                </h1>
                <p class="prose-description">
                    Lorem ipsum dolor sit amet consectetur, adipisicing elit. Odio atque neque non tempora, dignissimos similique deserunt quaerat culpa autem accusamus obcaecati illo laboriosam pariatur consectetur! Voluptatem dolores numquam alias quibusdam.
                </p>
            </a>
        </section>
    </main>
    <!-- MAIN SECTION ENDS -->

    <script>
        // Internal JavaScript
    </script>
    <script src="script-variables.js" defer>
    </script>
    <script src="script-elements.js" defer>
    </script>
    <script src="script-global.js" defer></script>
</body>

</html>
